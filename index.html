<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>캠페인 빌더 v26.0 (최종 개선안)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap">
    <style>
        body, html {
            font-family: 'Inter', sans-serif;
            background-color: #0d0c12;
            color: #e5e7eb;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
        #sphere-canvas {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .ui-container {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        main {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        footer {
            flex-shrink: 0;
        }
        
        /* Accordion styles */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        .accordion-content.open {
            max-height: 500px; /* 충분한 높이 */
            padding-top: 0.75rem; /* py-3 */
            padding-bottom: 0.75rem;
        }
    </style>
</head>
<body>
    <canvas id="sphere-canvas"></canvas>

    <div class="ui-container max-w-md mx-auto">
        <!-- 메인 대시보드 -->
        <main>
            <div class="text-center">
                <p class="text-gray-400 text-lg">예상 도달</p>
                <p id="total-reach" class="text-7xl font-extrabold text-white transition-all duration-300">0</p>
            </div>
        </main>

        <!-- 하단 카드 섹션 -->
        <footer class="px-4 pb-6 pt-4">
            <div id="accordion-container" class="space-y-3 mb-4">
                <!-- 아코디언 카드들이 여기에 동적으로 렌더링됩니다. -->
            </div>
            <div class="flex justify-between items-center mb-3">
                <span class="text-gray-400">총 합계 (VAT 별도)</span>
                <span id="total-price" class="text-xl font-bold text-white">0원</span>
            </div>
            <button id="submit-campaign-btn" class="w-full bg-blue-600 text-white font-bold py-3 rounded-full text-base disabled:bg-gray-700 disabled:cursor-not-allowed">
                캠페인 신청하기
            </button>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Connecting Sphere Canvas Logic ---
            const canvas = document.getElementById('sphere-canvas');
            const ctx = canvas.getContext('2d');
            
            let points = [];
            const numPoints = 2500;
            let beams = [];
            let targetIntensity = 0;
            let currentIntensity = 0;
            let targetLineCount = 0;
            let rotationX = 0;
            let rotationY = 0;
            let time = 0;

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Create points on a sphere
            for (let i = 0; i < numPoints; i++) {
                const phi = Math.acos(-1 + (2 * i) / numPoints);
                const theta = Math.sqrt(numPoints * Math.PI) * phi;
                points.push({
                    x: Math.cos(theta) * Math.sin(phi),
                    y: Math.sin(theta) * Math.sin(phi),
                    z: Math.cos(phi)
                });
            }

            class Beam {
                constructor(startIndex, endIndex) {
                    this.startIndex = startIndex;
                    this.endIndex = endIndex;
                }
                draw(projectedPoints) {
                    const p1 = projectedPoints[this.startIndex];
                    const p2 = projectedPoints[this.endIndex];
                    if (!p1 || !p2) return;

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    
                    // Use the color of the starting point for the line
                    const lineOpacity = currentIntensity * 0.4;
                    const lineColor = p1.color.replace(/, [0-9\.]+\)/, `, ${lineOpacity})`);
                    
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 1.2;
                    ctx.stroke();
                }
            }

            function updateSphere(reach) {
                // Set maxReach to 300,000 for higher sensitivity
                const maxReach = 300000; 
                const maxLines = 800;
                const reachRatio = Math.pow(Math.min(reach / maxReach, 1), 0.6);
                
                targetIntensity = reachRatio;
                targetLineCount = Math.floor(reachRatio * maxLines);
            }

            function drawSphere() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const radius = Math.min(canvas.width, canvas.height) * 0.3;
                const fov = 300;
                
                currentIntensity += (targetIntensity - currentIntensity) * 0.05;
                rotationX += 0.001;
                rotationY += 0.0005;
                time += 0.02;

                const projectedPoints = points.map(p => {
                    const deformation = Math.sin(p.y * 5 + time) * Math.cos(p.x * 5 + time) * 0.1 * currentIntensity;
                    const r = 1 + deformation;

                    const cosX = Math.cos(rotationX);
                    const sinX = Math.sin(rotationX);
                    const cosY = Math.cos(rotationY);
                    const sinY = Math.sin(rotationY);

                    const y1 = p.y * cosX - p.z * sinX;
                    const z1 = p.y * sinX + p.z * cosX;
                    const x1 = p.x * cosY - z1 * sinY;
                    const z2 = p.x * sinY + z1 * cosY;

                    const scale = fov / (fov + z2 * radius);
                    const px = x1 * r * radius * scale + canvas.width / 2;
                    const py = y1 * r * radius * scale + canvas.height / 2;
                    
                    const brightness = Math.max(0, (p.z + 1) / 2);
                    const hue = 260 + brightness * 60 - currentIntensity * 60;
                    const lightness = 60 + brightness * 30 * currentIntensity;
                    const alpha = 0.3 + brightness * 0.7 * currentIntensity;
                    const color = `hsla(${hue}, 100%, ${lightness}%, ${alpha})`;
                    
                    return { x: px, y: py, z: z2, scale: scale, color: color };
                });
                
                // Adjust beam array to match target count
                while (beams.length < targetLineCount) {
                    const startIndex = Math.floor(Math.random() * numPoints);
                    let endIndex = Math.floor(Math.random() * numPoints);
                    while (endIndex === startIndex) {
                        endIndex = Math.floor(Math.random() * numPoints);
                    }
                    beams.push(new Beam(startIndex, endIndex));
                }
                while (beams.length > targetLineCount) {
                    beams.shift(); // Remove oldest beams
                }

                // Draw beams
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(200, 200, 255, 0.3)';
                beams.forEach(beam => beam.draw(projectedPoints));
                ctx.shadowBlur = 0;


                // Draw points
                projectedPoints.forEach(p => {
                    if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) return;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.scale * 1.2, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                });

                requestAnimationFrame(drawSphere);
            }
            drawSphere();

            // --- Campaign Builder Logic ---
            const productsData = {
                'blog': { name: '네이버 블로그', items: [
                    { id: 'blog-seed', name: '블로그(씨앗)', price: 80000, reach: 1250 },
                    { id: 'blog-sprout', name: '블로그(새싹)', price: 150000, reach: 6000 },
                    { id: 'blog-fruit', name: '블로그(열매)', price: 300000, reach: 15000 },
                ]},
                'insta': { name: '인스타그램', items: [
                    { id: 'insta-micro-img', name: '인스타(이미지)', price: 200000, reach: 30000 },
                    { id: 'insta-micro-vid', name: '인스타(숏폼)', price: 450000, reach: 30000 },
                    { id: 'insta-mid-mix', name: '인스타(이미지+숏폼)', price: 1200000, reach: 100000 },
                ]}
            };

            const cart = {};

            const totalReachEl = document.getElementById('total-reach');
            const accordionContainer = document.getElementById('accordion-container');
            const totalPriceEl = document.getElementById('total-price');
            const submitBtn = document.getElementById('submit-campaign-btn');
            
            function renderAccordion() {
                let html = '';
                for (const channelId in productsData) {
                    const channel = productsData[channelId];
                    let productHtml = '';
                    channel.items.forEach(product => {
                        const quantity = cart[product.id] || 0;
                        productHtml += `
                            <div class="flex justify-between items-center bg-gray-800 p-3 rounded-lg">
                                <div>
                                    <p class="font-semibold text-white">${product.name}</p>
                                    <p class="text-sm text-gray-400">${product.price.toLocaleString()}원</p>
                                </div>
                                <div class="flex items-center space-x-3">
                                    <button data-id="${product.id}" class="cart-quantity-change bg-gray-700 rounded-full w-8 h-8 text-xl font-light">-</button>
                                    <span class="font-bold text-white text-lg w-8 text-center">${quantity}</span>
                                    <button data-id="${product.id}" class="cart-quantity-change bg-blue-600 rounded-full w-8 h-8 text-xl font-light">+</button>
                                </div>
                            </div>
                        `;
                    });

                    html += `
                        <div class="accordion-item bg-gray-900 rounded-xl border border-gray-800 overflow-hidden">
                            <button class="accordion-header w-full text-left p-4 flex justify-between items-center">
                                <span class="font-bold text-white">${channel.name}</span>
                                <svg class="w-5 h-5 text-gray-400 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                            </button>
                            <div class="accordion-content px-4 space-y-3">
                                ${productHtml}
                            </div>
                        </div>
                    `;
                }
                accordionContainer.innerHTML = html;
                addAccordionListeners();
            }

            let animationFrameId;
            function animateMainReach(endValue) {
                const startValue = parseInt(totalReachEl.textContent.replace(/,/g, '')) || 0;
                if (startValue === endValue) return;
                const duration = 1000;
                let startTime = null;
                function step(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = Math.min((timestamp - startTime) / duration, 1);
                    const currentValue = Math.floor(progress * (endValue - startValue) + startValue);
                    totalReachEl.textContent = currentValue.toLocaleString();
                    if (progress < 1) animationFrameId = requestAnimationFrame(step);
                }
                cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(step);
            }

            function updateTotals() {
                let totalPrice = 0;
                let totalReach = 0;
                for (const channelId in productsData) {
                    productsData[channelId].items.forEach(product => {
                        if (cart[product.id]) {
                            totalPrice += product.price * cart[product.id];
                            totalReach += product.reach * cart[product.id];
                        }
                    });
                }
                totalPriceEl.textContent = `${totalPrice.toLocaleString()}원`;
                submitBtn.disabled = totalPrice === 0;
                animateMainReach(totalReach);
                updateSphere(totalReach);
            }

            function addAccordionListeners() {
                const headers = document.querySelectorAll('.accordion-header');
                headers.forEach(header => {
                    header.addEventListener('click', () => {
                        const content = header.nextElementSibling;
                        const icon = header.querySelector('svg');
                        
                        document.querySelectorAll('.accordion-content.open').forEach(openContent => {
                            if (openContent !== content) {
                                openContent.classList.remove('open');
                                openContent.previousElementSibling.querySelector('svg').classList.remove('rotate-180');
                            }
                        });

                        content.classList.toggle('open');
                        icon.classList.toggle('rotate-180');
                    });
                });

                const quantityButtons = document.querySelectorAll('.cart-quantity-change');
                quantityButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const id = btn.dataset.id;
                        const operation = btn.textContent;
                        
                        if (operation === '+') {
                            if ((cart[id] || 0) < 100) {
                                cart[id] = (cart[id] || 0) + 1;
                            }
                        } else if (operation === '-') {
                            if (cart[id] && cart[id] > 0) {
                                cart[id]--;
                                if (cart[id] === 0) delete cart[id];
                            }
                        }
                        
                        const quantitySpan = btn.parentElement.querySelector('span');
                        quantitySpan.textContent = cart[id] || 0;
                        updateTotals();
                    });
                });
            }

            renderAccordion();
            updateTotals();
        });
    </script>
</body>
</html>
